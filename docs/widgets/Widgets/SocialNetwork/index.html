<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1"
    />
    <title>Book of Mormon Conversation Network</title>

    <link rel="stylesheet" href="../colors.css" />
    <link rel="stylesheet" href="styles.css" />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap"
      rel="stylesheet"
    />

    <script src="//unpkg.com/3d-force-graph"></script>
    <script src="//unpkg.com/d3-force-3d"></script>
  </head>

  <body>
    <div id="widget">
      <!-- 
        <div id="faq">
            <div id ="head"> 
                <div class="title"><h1>FAQ</h1></div>
                <div class="exit" onclick="faqDisappear()">X</div>
            </div>
            <div id="content">
                <br>
                <div class="question">
                    <h3>
                        What is this network diagram?
                    </h3>
                    <br>
                    <p>This diagram is an example of a consensus network. Consensus networks are a visually intuitive way to show the relative similarity between things that can be compared on several distinct axes. The concept of consensus networks was developed in phylogenetics, when researchers wanted a more robust way to compare organisms by several different aspects at once.
                    </p> 
                    <p>In our consensus networks, each node represents a text. Connections between the nodes indicate similarity between the nodes they connect. The strength of the connections (how hard they pull on their neigbors) is indicative of the level of similarity between the texts.
                    </p>
                    <br>
                </div>
                <div class="question">
                    <h3>
                        What do the spheres represent?
                    </h3>
                    <br>
                    <p>Each sphere (node) represents a character from the Book of Mormon.</p>
                    <br>
                </div>
                <div class="question">
                    <h3>
                        What do the connections represent?
                    </h3>
                    <br>
                    <p>Each connection represents one or more interactions between two speakers. Click on any connection to see a scripture describing an interaction between the two speakers.
                    </p>
                    <br>
                </div>
                <div class="question">
                    <h3>
                        What determines the placement of the nodes?
                    </h3>
                    <br>
                    <p>This network is uses force-directed graphing. In this system, the nodes sit in 3-D space, and pull towards each other where there are connections between them. Then, a force is applied to push the network apart. In the resulting graph, the speakers fall into place based on who they communicate with in the Book of Mormon.</p>
                    <br>
                </div>      
        </div>
    </div>
    <div id="grey-out" onclick="faqDisappear()"></div>
    -->
      <div id="page-container">
        <div id="headbar">
          <h1 style="display: none">Book of Mormon Conversation Network</h1>
        </div>
        <div id="graph-3d"></div>
        <div id="toolbar">
          <div id="recenterButton" class="button" onclick="resetGraph()">
            Re-Center Network
          </div>
          <div id="dimensionButton" class="button" onclick="cycleDimensions()">
            Change to 2-D
          </div>
          <div
            id="backgroundColorButton"
            class="button"
            onclick="changeBackgroundColor()"
          >
            Light Mode
          </div>
          <div
            id="connectionsButton"
            class="button"
            onclick="toggleConnections()"
          >
            Connections Off
          </div>
        </div>
        <div id="sidebar">
          <div id="side-menu">
            <button
              style="display: none"
              class="accordion"
              id="explanationTab"
              onclick="openTab('explanationTab')"
            >
              Explanation
            </button>
            <div style="display: none" class="panel">
              <div id="explanation" class="contents"></div>
            </div>
            <button
              style="display: none"
              class="accordion"
              id="instructionsTab"
              onclick="openTab('instructionsTab')"
            >
              Instructions
            </button>
            <div style="display: none" class="panel">
              <div id="instructions" class="contents"></div>
            </div>
            <button class="accordion" id="infoTab" onclick="openTab('infoTab')">
              Information
            </button>
            <div class="panel">
              <div id="info" class="contents">No speaker selected.</div>
            </div>
            <button
              class="accordion"
              id="legendTab"
              onclick="openTab('legendTab')"
            >
              Legend
            </button>
            <div class="panel">
              <div id="legend" class="contents">
                <!--                        <div id="legend-title"><h3>Colored by Name</h3></div>   -->
                <br />
                <div id="legend-selection-controls" style="display: none">
                  <div
                    style="
                      display: flex;
                      align-items: center;
                      justify-content: space-between;
                      gap: 10px;
                      margin: 0 0 10px 0;
                    "
                  >
                    <div
                      id="legend-selection-title"
                      style="font-weight: 700"
                    ></div>
                    <div style="display: flex; gap: 8px">
                      <button
                        type="button"
                        class="default-button"
                        onclick="legendSelectionReset()"
                      >
                        Reset
                      </button>
                      <button
                        type="button"
                        class="default-button"
                        onclick="legendSelectionShowAll()"
                      >
                        Show all
                      </button>
                    </div>
                  </div>
                </div>
                <div id="checkbox-holder-global"></div>
                <div id="checkbox-holder-selection" style="display: none"></div>
                <!--
                        <br>
                        <div id="button-holder">
                            <button id="checkButton" class='default-button' onclick="checkAll(true)">
                                Check All
                            </button>
                            <button id="uncheckButton" class='default-button' onclick = "checkAll(false)">
                                Uncheck All
                            </button>
                            <button id="toggle1" class="default-button" onclick = "changeColors(0, 'Name')">
                                Color by Name
                            </button>
                            <button id="toggle2" class="default-button" onclick = "changeColors(1, 'Righteousness')">
                                Color by Righteousness
                            </button>
                            <button id="toggle3" class="default-button" onclick = "changeColors(2, 'Nationality')">
                                Color by Nationality
                            </button>
                        </div>
                        -->
              </div>
            </div>
          </div>
          <div id="auxiliary">
            <!--                <div id="nav-instructions">  
                    Select a person
</div> -->
            <div id="node-select">
              <select id="bookSelect" onchange="flyToNode()">
                <option value="Aaron">Aaron</option>
                <option value="Abinadi">Abinadi</option>
                <option value="Abraham">Abraham</option>
                <option value="Adam">Adam</option>
                <option value="Aha">Aha</option>
                <option value="Ahaz">Ahaz</option>
                <option value="Akish">Akish</option>
                <option value="Alma">Alma</option>
                <option value="Alma2">Alma the Younger</option>
                <option value="Amalekite">Amalekite</option>
                <option value="Amalickiah">Amalickiah</option>
                <option value="Ammaron">Ammaron</option>
                <option value="Ammon">Ammon Son of Mosiah</option>
                <option value="Ammon2">Ammon the Mulekite</option>
                <option value="Ammoron">Ammoron</option>
                <option value="Amulek">Amulek</option>
                <option value="Angels">Angel</option>
                <option value="AntiNephiLehi">Anti-Nephi-Lehi</option>
                <option value="Antionah">Antionah</option>
                <option value="Antipus">Antipus</option>
                <option value="Benjamin">Benjamin</option>
                <option value="BrotherJared">Brother of Jared</option>
                <option value="BrothersNephi">Brothers of Nephi</option>
                <option value="CaptainMoroni">Captain Moroni</option>
                <option value="ChiefJudgeAmmonihah">
                  Chief Judge in Ammonihah
                </option>
                <option value="ChildrenLaman">Children of Laman</option>
                <option value="Christ">Christ in America</option>
                <option value="Corianton">Corianton</option>
                <option value="Coriantumr">Coriantumr</option>
                <option value="DaughterJared">
                  Daughter of Jared Son of Omer
                </option>
                <option value="DaughtersIshmael">Daughters of Ishmael</option>
                <option value="Enos">Enos</option>
                <option value="Ether">Ether</option>
                <option value="Eve">Eve</option>
                <option value="FatherLamoni">Father of Lamoni</option>
                <option value="Gid">Gid</option>
                <option value="Giddianhi">Giddianhi</option>
                <option value="Giddonah">Giddonah</option>
                <option value="Gideon">Gideon</option>
                <option value="Godhead">Godhead</option>
                <option value="Helam">Helam</option>
                <option value="Helaman">Helaman</option>
                <option value="Helaman3">Helaman Son of Benjamin</option>
                <option value="Helaman2">Helaman Son of Helaman</option>
                <option value="Helorum">Helorum</option>
                <option value="Himni">Himni</option>
                <option value="Isaiah">Isaiah</option>
                <option value="Ishmael">Ishmael</option>
                <option value="Jacob">Jacob</option>
                <option value="Jacob3">Jacob the Zoramite</option>
                <option value="Jared">Jared</option>
                <option value="Jared2">Jared Son of Omer</option>
                <option value="Jarom">Jarom</option>
                <option value="Joseph">Joseph in Egypt</option>
                <option value="Joseph2">Joseph</option>
                <option value="KingLaman">King Laman</option>
                <option value="Noah">King Noah</option>
                <option value="KingLamanites">King of the Lamanites</option>
                <option value="Kishkumen">Kishkumen</option>
                <option value="Korihor">Korihor</option>
                <option value="Laban">Laban</option>
                <option value="Lachoneus">Lachoneus</option>
                <option value="Laman">Laman</option>
                <option value="LamaniteKing">Lamanite King</option>
                <option value="LamaniteQueen">Lamanite Queen</option>
                <option value="Lamoni">Lamoni</option>
                <option value="Lehi">Lehi</option>
                <option value="Lehi2">Lehi Son of Helaman</option>
                <option value="Lehi3">Lehi Son of Zoram</option>
                <option value="Lehonti">Lehonti</option>
                <option value="Lemuel">Lemuel</option>
                <option value="Limhi">Limhi</option>
                <option value="Malachi">Malachi</option>
                <option value="Mormon">Mormon</option>
                <option value="Moroni">Moroni</option>
                <option value="Moses">Moses</option>
                <option value="Mosiah">Mosiah</option>
                <option value="Mosiah2">Mosiah Father of Benjamin</option>
                <option value="Nehor">Nehor</option>
                <option value="Nephi">Nephi</option>
                <option value="Nephi2">Nephi Son of Helaman</option>
                <option value="Nephi3">
                  Nephi Son of Nephi Son of Helaman
                </option>
                <option value="Nephihah">Nephihah</option>
                <option value="Omer">Omer</option>
                <option value="Omner">Omner</option>
                <option value="Omni">Omni</option>
                <option value="Pahoran">Pahoran</option>
                <option value="PriestsNoah">Priests of Noah</option>
                <option value="MotherLamoni">Queen of Father of Lamoni</option>
                <option value="Sam">Sam</option>
                <option value="SamuelLamanite">Samuel the Lamanite</option>
                <option value="Sariah">Sariah</option>
                <option value="Satan">Satan</option>
                <option value="ServantsFatherLamoni">
                  Servant of Father of Lamoni
                </option>
                <option value="ServantHelaman">Servant of Helaman</option>
                <option value="ServantLamoni">Servant of Lamoni</option>
                <option value="ServantsLamoni">Servants of Lamoni</option>
                <option value="Sherem">Sherem</option>
                <option value="Shiblon">Shiblon</option>
                <option value="Shiz">Shiz</option>
                <option value="ChildrenLemuel">
                  Sons and Daughters of Lemuel
                </option>
                <option value="SonsIshmael">Sons of Ishmael</option>
                <option value="StriplingWarriors">Stripling Warriors</option>
                <option value="Teancum">Teancum</option>
                <option value="ThreeNephites">Three Nephites</option>
                <option value="TwelveDisciples">Twelve Disciples</option>
                <option value="WifeIshmael">Wife of Ishmael</option>
                <option value="WifeLamoni">Wife of Lamoni</option>
                <option value="WivesSonsIshmael">
                  Wives of Sons of Ishmael
                </option>
                <option value="Zeezrom">Zeezrom</option>
                <option value="Zeniff">Zeniff</option>
                <option value="Zenock">Zenock</option>
                <option value="Zenos">Zenos</option>
                <option value="Zerahemnah">Zerahemnah</option>
                <option value="Zoram">Zoram</option>
                <option value="Zoram2">Zoram Captain of Nephites</option>
              </select>
              <!--
                    <button id="goButton" class='default-button' onclick="flyToNode()">
                        Go!
                    </button>
                    -->
            </div>
          </div>
        </div>
      </div>
      <script type="text/javascript" src="utils.js"></script>
      <script>
        // Inline index.js

        // Initialize checkbox vars
        const onNames = new Set();
        const colorNodes = new Set();
        const highlightLinks = new Set();

        // Initialize size vars for graph creation
        var windowWidth = window.innerWidth;
        var windowHeight = window.innerHeight;
        var graphWidth = windowWidth - 500;
        var graphHeight = windowHeight - 500;
        var sideSizeMin = windowHeight - 275;
        var sideSizeMax = windowHeight - 275;

        var graphExtraHeight = 110;
        var graphExtraWidth = 310;
        var graphExtraWidthMed = 260;
        var graphExtraWidthSmall = 10;
        var graphExtraSideHeight = 210;
        var graphExtraSideHeightSmall = 210;
        var minAccordionHeight = 426;

        // Initialize vars for highlighting when nodes are right-clicked
        var selectedNode = null;
        var highlightMode = false;
        var coloring = 0;
        const targetNodes = new Set();
        const incomingNodes = new Set();
        const outgoingNodes = new Set();
        const inHighlightLinks = new Set();
        const outHighlightLinks = new Set();

        const visibleLinks = new Set();
        var connectionDisplay = 1;
        var dimensions = 3;
        var lineWidth = 1;

        // Legend mode:
        // - "all": show global legend categories (current behavior)
        // - "selection": show only exact people in the selected neighborhood
        var legendMode = "all";
        var selectionRootId = null;
        var selectionNeighborhoodIds = [];
        // In selection mode, we only hide/unhide *neighborhood people*.
        // Keep all other nodes visible (so the rest of the graph stays translucent).
        const selectionHiddenIds = new Set();

        // Set initial color for nodes and background and node drag
        var graphColoring = "text";
        var backgroundColor = "light";

        // Theme colors
        var transparentDark = "rgba(34, 34, 34, 0.5)";
        var transparentlight = "rgba(236, 236, 236, 0.5)";
        var lightBackgroundColor = "#ffffff";
        var darkBackgroundColor = "#222222";

        // Create graph
        // Documentation for this library is at https://github.com/vasturiano/3d-force-graph
        const Graph = ForceGraph3D({ controlType: "orbit" })(
          document.getElementById("graph-3d"),
        )
          .jsonUrl("unpruned.json")
          .nodeLabel("Label")
          //.linkLabel('Reference')
          .nodeResolution([15])
          .nodeRelSize([2])
          .linkWidth(["Weight"])
          .nodeOpacity([1])
          .linkOpacity([0.75])
          .nodeColor("Color")
          .nodeVal("Scaled3")
          .nodeId(["Id"])
          .linkSource(["Source"])
          .linkTarget(["Target"])
          //since we are creating the graph here, we can't resize the canvas with media queries.
          .width(windowWidth < 500 ? windowWidth : graphWidth)
          .height(windowWidth < 500 ? windowHeight - 25 : graphHeight)
          .linkWidth(lineWidth)
          // make spherical bound
          .d3Force("radial", d3.forceRadial(1))
          .backgroundColor("#222222")
          .onLinkClick((link) => {
            showLinkInfo(link);
            closeAccordion();
            openTab("infoTab");
            // dehighlightGraph();
          })
          .onLinkHover((link, link2) => {
            linkHover(link, link2);
          })
          .onNodeClick((node, event) => {
            highlightSpeaker(node.Label);
          })
          .onNodeRightClick((node) => {
            highlightNode(node);
          })
          .onBackgroundClick(() => {
            dehighlightGraph();
          });

        // Update each link's visibility status
        function updateVisibleLinks() {
          visibleLinks.clear();
          var links = Graph.graphData().links;

          // Cache a nodeId -> node map for resolving link endpoints (links may store ids or node objects)
          const nodesById = getNodesByIdMap();
          const resolveNode = (endpoint) => {
            if (!endpoint) return null;
            if (typeof endpoint === "object") return endpoint;
            return nodesById.get(endpoint) || null;
          };

          const endpointsVisible = (link) => {
            const src = resolveNode(link.source);
            const tgt = resolveNode(link.target);

            // If we can't resolve endpoints, don't hide (avoid transient bugs during graph init)
            if (!src || !tgt) return true;

            // Respect global legend filter (colorNodes) and selection legend hides
            if (!colorNodes.has(src) || !colorNodes.has(tgt)) return false;
            if (
              legendMode === "selection" &&
              (selectionHiddenIds.has(src.Id) || selectionHiddenIds.has(tgt.Id))
            )
              return false;

            return true;
          };

          for (index = 0; index < links.length; index++) {
            link = links[index];
            if (connectionDisplay) {
              visibleLinks.add(link);
            }
          }

          // Hide any link connected to a hidden node
          Graph.linkVisibility((link) =>
            visibleLinks.has(link) &&
            highlightLinks.has(link) &&
            endpointsVisible(link)
              ? 1
              : 0,
          );
        }

        // Apply node visibility considering both:
        // global legend filters (colorNodes)
        // selection legend filters (selectionHiddenIds) when legendMode === "selection"
        function applyCurrentNodeVisibility() {
          if (legendMode === "selection") {
            Graph.nodeVisibility((node) =>
              colorNodes.has(node) && !selectionHiddenIds.has(node.Id) ? 1 : 0,
            );
          } else {
            Graph.nodeVisibility((node) => (colorNodes.has(node) ? 1 : 0));
          }
        }

        // Resize links (used on hover)
        function linkHover(link, link2) {
          if (link != null) {
            //on hover start
            link.Weight = 2;
            Graph.linkWidth("Weight");
          } else {
            //on hover end
            link2.Weight = 1;
            Graph.linkWidth("Weight");
          }
        }

        // Return graph to default colors
        function dehighlightGraph() {
          highlightMode = false;
          selectedNode = null;
          // return nodes to proper color
          if (coloring == 1) {
            Graph.nodeColor("Color1");
          } else if (coloring == 2) {
            Graph.nodeColor("Color2");
          } else {
            Graph.nodeColor("Color");
          }
          // Turn on link visibility and size
          Graph.linkOpacity([0.75]);
          if (backgroundColor === "dark") {
            Graph.linkColor((link) => "#ffffff");
          } else {
            Graph.linkColor((link) => "#888888");
          }
          Graph.linkWidth(lineWidth);
          updateVisibleLinks();
          // Clean out sets for selective highlighting
          inHighlightLinks.clear();
          outHighlightLinks.clear();
          incomingNodes.clear();
          outgoingNodes.clear();
          targetNodes.clear();
          destroyLabel();

          // Restore full legend when selection is cleared
          if (legendMode === "selection") {
            legendSelectionExit();
          }
        }

        // Dynamically resize the canvas on window resize
        window.onresize = resizeGraph;

        const appHeight = () =>
          document.documentElement.style.setProperty(
            "--app-height",
            `${window.innerHeight}px`,
          );
        window.addEventListener("resize", appHeight);
        appHeight();

        function resizeGraph() {
          // In column layout, keep the graph shorter so the user can reach content below without fighting
          // the graph's scroll-to-zoom behavior on trackpads/mice.
          if (window.innerWidth <= 1024) {
            const desired = Math.floor(window.innerHeight * 0.55);
            const clamped = Math.max(320, Math.min(650, desired));
            Graph.height(clamped);
          } else {
            Graph.height(window.innerHeight - graphExtraHeight);
          }

          // Match CSS: below laptop width we use a column layout, so the graph should use (nearly) full width.
          if (window.innerWidth > 1024) {
            Graph.width(window.innerWidth - graphExtraWidth);
            sideSizeMin = window.innerHeight - graphExtraSideHeight;
            sideSizeMax = window.innerHeight - graphExtraSideHeight;
          } else {
            Graph.width(window.innerWidth - graphExtraWidthSmall);
            sideSizeMin = 1;
            sideSizeMax = window.innerHeight;
          }

          populateInstructions();
          populateNavInfo();
          setSidebarSize(sideSizeMin, sideSizeMax);
          resetGraph();
        }

        // Dynamically set max height on sidemenu (to be used whenever graph resizes or first renders)
        function setSidebarSize(sizeMin, sizeMax) {
          var sideMenu = document.getElementById("side-menu");
          sideMenu.style.maxHeight = sizeMax.toString() + "px";
          sideMenu.style.minHeight = sizeMin.toString() + "px";
        }

        // Set correct colors for highlighting selected nodes and edges
        function setHighlightColor() {
          console.log(Graph.graphData().nodes[0]);
          // Combined highlight logic.
          Graph.nodeColor((node) => {
            // Selected node color depends on background for contrast
            if (node === selectedNode) {
              return backgroundColor === "dark"
                ? "rgba(255, 255, 255, 1)"
                : "rgba(155, 155, 155, 1)";
            }
            // Highlighted nodes use their designated color
            if (
              targetNodes.has(node) ||
              incomingNodes.has(node) ||
              outgoingNodes.has(node)
            ) {
              if (coloring == 1) return node.Color1;
              if (coloring == 2) return node.Color2;
              return node.Color;
            }
            // Non-highlighted nodes are translucent
            return "rgba(211, 211, 211, 0.3)";
          });

          // Set link colors, dependent on background color
          const isSelectedLink = (link) =>
            selectedNode &&
            (link.source === selectedNode || link.target === selectedNode);

          if (backgroundColor == "dark") {
            Graph.linkColor((link) =>
              isSelectedLink(link)
                ? "rgba(255, 64, 64, 1)"
                : inHighlightLinks.has(link) || outHighlightLinks.has(link)
                  ? "#ffffff"
                  : "rgba(211, 211, 211, 0.3)",
            );
          } else {
            Graph.linkColor((link) =>
              isSelectedLink(link)
                ? "rgba(204, 0, 0, 1)"
                : inHighlightLinks.has(link) || outHighlightLinks.has(link)
                  ? "#888888"
                  : "rgba(211, 211, 211, 0.3)",
            );
          }

          // Keep link widths consistent (no size increase on selected links)
          Graph.linkWidth(1);
        }

        // Return graph to default display
        function resetGraph() {
          destroyLabel();
          Graph.zoomToFit(500, -75);
        }

        // Get the screen coordinates of the center of the graph
        function getGraphCenterCoords() {
          var height = window.innerHeight - 350;
          var width;

          if (window.innerHeight > 500) {
            width = window.innerWidth - 150;
          } else {
            width = window.innerWidth - 250;
          }

          return [Math.floor(width / 2), Math.floor(height / 2)];
        }

        // Toggle graph background between light and dark color palettes
        function changeBackgroundColor() {
          buttonText = document.getElementById("backgroundColorButton");

          if (backgroundColor === "dark") {
            backgroundColor = "light";
            Graph.backgroundColor(lightBackgroundColor);
            Graph.linkColor((link) => "#888888");
            buttonText.innerHTML = "Dark Mode";
            document.getElementsByClassName("scene-nav-info")[0].style.color =
              "#222222";
          } else {
            Graph.backgroundColor(darkBackgroundColor);
            backgroundColor = "dark";
            Graph.linkColor((link) => "#ffffff");
            document.getElementsByClassName("scene-nav-info")[0].style.color =
              "#fafafa";
            buttonText.innerHTML = "Light Mode";
          }

          if (highlightMode == true) {
            setHighlightColor();
          }

          //    updateTooltipColor();
          updatePopupColor();
        }

        /*   // Does not apply in this widget
        // Update tooltip (called when we change the graph background color)
        function updateTooltipColor(){
            var tooltip = document.getElementsByClassName("scene-tooltip")[0];

            if (backgroundColor === 'dark') {
                tooltip.style.backgroundColor = transparentDark;
                tooltip.style.color = "#ffffff";
            } else {
                tooltip.style.backgroundColor = "rgba(228,237,240, 0.5)";
                tooltip.style.color = "#000000";	  
            }
        }
*/

        // Update popup label color (called when we change the graph background color)
        function updatePopupColor() {
          var popup = document.getElementById("popup");

          if (popup) {
            if (backgroundColor === "dark") {
              popup.style.backgroundColor = transparentDark;
              popup.style.color = "#ffffff";
            } else {
              popup.style.backgroundColor = transparentlight;
              popup.style.color = "#000000";
            }
          }
        }

        /*......Functions to change graph between 3-D and 2-D......*/
        function updateDimensions() {
          Graph.numDimensions(dimensions);
        }

        // Cycle between 2 or 3 dimensions
        function cycleDimensions() {
          destroyLabel();

          var button = document.getElementById("dimensionButton");
          var explanationText = document.getElementById("Explanation");

          if (dimensions == 3) {
            dimensions = 2;
            button.innerHTML = "Change to 3-D";
          } else {
            dimensions = 3;
            button.innerHTML = "Change to 2-D";
          }

          populateExplanation();
          updateDimensions();
        }

        // Change graph coloring scheme
        function changeColors(colorInt, colorText) {
          elem = document.getElementById("legend-title");
          elem.innerHTML = `Colored by ${colorText}`;
          coloring = colorInt;
          populateCheckboxes();
          dehighlightGraph();
          checkAll(true);
        }

        /*......Functions to give funtionality to the checkboxes in the legend......*/

        // Check all legend checkboxes
        function checkAll(checked) {
          var speakersLength = 0;
          var list = [];

          if (coloring == 1) {
            list = speakers1;
          } else if (coloring == 2) {
            list = speakers2;
          } else {
            list = speakers;
          }

          speakersLength = list.length;

          for (var i = 0; i < speakersLength; i++) {
            document.getElementById(list[i]).checked = checked;
          }

          updateVisibleLinks();
          check();
        }

        // Create checkbox item for each element in list of all speakers
        function check() {
          // Clear sets of names, color nodes, and highlight links
          onNames.clear();
          colorNodes.clear();
          highlightLinks.clear();

          var nodes = Graph.graphData().nodes;
          var links = Graph.graphData().links;

          // Loop over all speakers, add each checked one to set
          var speakersLength = 0;
          var list = [];

          if (coloring == 1) {
            speakersLength = speakers1.length;
            list = speakers1;
          } else if (coloring == 2) {
            speakersLength = speakers2.length;
            list = speakers2;
          } else {
            speakersLength = speakers.length;
            list = speakers;
          }

          for (var i = 0; i < speakersLength; i++) {
            var x = document.getElementById(list[i]).checked;

            if (x == true) {
              onNames.add(document.getElementById(list[i]).id);
            }
          }

          // iterate over nodes, add correct ones to the set
          for (index = 0; index < nodes.length; index++) {
            node = nodes[index];
            if (coloring == 1) {
              if (onNames.has(node.Group1)) {
                colorNodes.add(node);
              }
            } else if (coloring == 2) {
              if (onNames.has(node.Group2)) {
                colorNodes.add(node);
              }
            } else {
              if (onNames.has(node.Name)) {
                colorNodes.add(node);
              }
            }
          }

          // iterate over links, add correct ones to the set
          for (index = 0; index < links.length; index++) {
            link = links[index];

            if (colorNodes.has(link.source)) {
              if (colorNodes.has(link.target)) {
                highlightLinks.add(link);
              }
            }
          }

          updateVisibleLinks();
          applyCurrentNodeVisibility();
        }

        // -------- Selection Legend (exact people) ----------
        function getNodesByIdMap() {
          const map = new Map();
          const nodes = Graph.graphData().nodes || [];
          for (let i = 0; i < nodes.length; i++) {
            const n = nodes[i];
            map.set(n.Id, n);
          }
          return map;
        }

        function getSelectionNeighborhoodNodes() {
          if (!selectedNode) return [];

          const nodesById = getNodesByIdMap();
          const byId = new Map();

          const addNode = (n) => {
            if (!n || n.Id === undefined || n.Id === null) return;
            byId.set(n.Id, n);
          };

          // Prefer the sets that represent the highlighted neighborhood
          addNode(selectedNode);
          targetNodes.forEach(addNode);
          incomingNodes.forEach(addNode);
          outgoingNodes.forEach(addNode);

          // Fallback: if sets are empty for some reason, use selectedNode.Ids
          if (
            byId.size <= 1 &&
            typeof selectedNode.Ids === "string" &&
            selectedNode.Ids.trim().length
          ) {
            const ids = selectedNode.Ids.trim()
              .split(/\s+/)
              .map(Number)
              .filter(Number.isFinite);
            for (const id of ids) {
              addNode(nodesById.get(id));
            }
          }

          const arr = Array.from(byId.values());
          arr.sort((a, b) => {
            if (a.Id === selectedNode.Id) return -1;
            if (b.Id === selectedNode.Id) return 1;
            return (a.Label || "").localeCompare(b.Label || "");
          });

          return arr;
        }

        function renderSelectionLegend(neighborhoodNodes) {
          const holder = document.getElementById("checkbox-holder-selection");
          if (!holder) return;

          let html = "";
          for (const n of neighborhoodNodes) {
            const isSelected = selectedNode && n.Id === selectedNode.Id;
            const checked = !selectionHiddenIds.has(n.Id);
            const label = n.Label || n.Name || `Id ${n.Id}`;
            const swatchColor =
              n.Color && typeof n.Color === "string" ? n.Color : "#ddd";
            html += `
                    <label class="container">
                        ${label}
                        <input type="checkbox"
                               ${checked ? "checked" : ""}
                               ${isSelected ? "disabled" : ""}
                               ${isSelected ? "" : `onchange="legendSelectionToggle(${n.Id})"`}
                        >
                        <span class="checkmark" style="background-color:${checked ? swatchColor : "#eee"}; border-color:${swatchColor};"></span>
                    </label>
                `;
          }

          holder.innerHTML = html;
        }

        function updateSelectionLegendControls() {
          const controls = document.getElementById("legend-selection-controls");
          const title = document.getElementById("legend-selection-title");
          if (!controls || !title) return;

          if (legendMode === "selection" && selectedNode) {
            controls.style.display = "block";
            title.innerText = `Selection (${selectionNeighborhoodIds.length} people)`;
          } else {
            controls.style.display = "none";
            title.innerText = "";
          }
        }

        function legendSelectionEnter() {
          if (!selectedNode) return;

          legendMode = "selection";
          selectionRootId = selectedNode.Id;

          const neighborhood = getSelectionNeighborhoodNodes();
          selectionNeighborhoodIds = neighborhood.map((n) => n.Id);

          selectionHiddenIds.clear();
          // Never allow the selected node itself to be hidden
          selectionHiddenIds.delete(selectedNode.Id);

          updateSelectionLegendControls();
          // Swap legend UI: keep global checkboxes in DOM (hidden) so check()/checkAll never crash
          const globalHolder = document.getElementById(
            "checkbox-holder-global",
          );
          const selectionHolder = document.getElementById(
            "checkbox-holder-selection",
          );
          if (globalHolder) globalHolder.style.display = "none";
          if (selectionHolder) selectionHolder.style.display = "block";
          renderSelectionLegend(neighborhood);
          applyCurrentNodeVisibility();
          updateVisibleLinks();
        }

        function legendSelectionExit() {
          legendMode = "all";
          selectionRootId = null;
          selectionNeighborhoodIds = [];
          selectionHiddenIds.clear();

          updateSelectionLegendControls();
          const globalHolder = document.getElementById(
            "checkbox-holder-global",
          );
          const selectionHolder = document.getElementById(
            "checkbox-holder-selection",
          );
          if (selectionHolder) selectionHolder.style.display = "none";
          if (globalHolder) globalHolder.style.display = "block";
          // IMPORTANT: Do NOT rebuild global checkbox HTML here.
          // Rebuilding resets checked states to default (usually unchecked), which can hide the entire graph.
          // Just clear selection-mode hiding and re-apply visibility based on the existing global checkbox state.
          applyCurrentNodeVisibility();
          updateVisibleLinks();
        }

        function legendSelectionToggle(nodeId) {
          if (legendMode !== "selection") return;
          // Never allow hiding the selected node
          if (selectedNode && nodeId === selectedNode.Id) return;

          if (selectionHiddenIds.has(nodeId)) selectionHiddenIds.delete(nodeId);
          else selectionHiddenIds.add(nodeId);

          // Re-render so the color swatches update immediately
          renderSelectionLegend(getSelectionNeighborhoodNodes());
          applyCurrentNodeVisibility();
          updateVisibleLinks();
        }

        function legendSelectionReset() {
          if (legendMode !== "selection") return;
          selectionHiddenIds.clear();
          // Never allow the selected node itself to be hidden
          if (selectedNode) selectionHiddenIds.delete(selectedNode.Id);
          renderSelectionLegend(getSelectionNeighborhoodNodes());
          applyCurrentNodeVisibility();
          updateVisibleLinks();
        }

        function legendSelectionShowAll() {
          // Full reset: unselect node, clear highlights/selection legend, and recenter the camera.
          // dehighlightGraph() will also restore the full legend UI if we're in selection mode.
          dehighlightGraph();
          resetGraph();
        }

        // For debug: export graph info (current node; edge positions) as JSON to the console
        function exportSnapshot() {
          var nodes = Graph.graphData().nodes;
          var links = Graph.graphData().links;
          nodesJSON = JSON.stringify(nodes, null, 4);
          console.log(nodesJSON);

          linksJSON = "[";
          for (index = 0; index < links.length; index++) {
            link = links[index];
            info = `\n{
                    "weight": ${link.Line_Width},
                    "sourceX": ${link.source.x},
                    "sourceY": ${link.source.y},
                    "sourceZ": ${link.source.z},
                    "targetX": ${link.target.x},
                    "targetY": ${link.target.y},
                    "targetZ": ${link.target.z}
                },`;
            linksJSON += info;
          }
          noTrailingComma = linksJSON.slice(0, -1);
          noTrailingComma += "\n]";
          console.log(noTrailingComma);
        }

        /*......Functions to control sidebar accordion menu......*/

        // Open one of the accordion tabs
        function openTab(tab) {
          explanation = document.getElementById(tab);
          open = explanation.classList.contains("active");
          closeAccordion();

          if (!open) {
            explanation.classList.add("active");
            var panel = explanation.nextElementSibling;
            panel.style.maxHeight = "400vh";

            if (window.innerWidth < 500) {
              minHeight = 0;
            } else {
              minHeight = window.innerHeight - minAccordionHeight;
            }

            panel.style.minHeight = minHeight.toString() + "px";
          }
        }

        // Close all of the accordion tabs
        function closeAccordion() {
          var accordion = document.getElementsByClassName("accordion");
          var i;

          for (i = 0; i < accordion.length; i++) {
            current = accordion[i];
            current.classList.remove("active");
            var panel = current.nextElementSibling;
            panel.style.maxHeight = null;
            panel.style.minHeight = null;
          }
        }
        // Move the graph to center a given node based on the select menu 
        function flyToNode(){
            selectedNode = null;
            var nodes = Graph.graphData().nodes;
            var book = document.getElementById("bookSelect").value;
            for (index = 0; index < nodes.length; index++) {
                node = nodes[index]
                
                if (node.Name === book) {
                    selectedNode = node;
                    break;
                }
            } 
            const distance = 70;
        }

        // Move the graph to center a given node based on the select menu
        function flyToNode() {
          selectedNode = null;
          var nodes = Graph.graphData().nodes;
          var book = document.getElementById("bookSelect").value;
          for (index = 0; index < nodes.length; index++) {
            node = nodes[index];

            if (node.Name === book) {
              selectedNode = node;
            }
          }
          const distance = 70;

          // a 2-D graph needs different camera parameters vice a 3-D graph
          if (dimensions == 2) {
            Graph.cameraPosition(
              { x: selectedNode.x, y: selectedNode.y, z: 250 },
              { x: selectedNode.x, y: selectedNode.y, z: 0 },
              1000,
            );
          } else {
            const distRatio =
              (1 +
                distance /
                  Math.hypot(selectedNode.x, selectedNode.y, selectedNode.z)) *
              2;

            Graph.cameraPosition(
              {
                x: selectedNode.x * distRatio,
                y: selectedNode.y * distRatio,
                z: selectedNode.z * distRatio,
              },
              selectedNode,
              1000,
            );
          }

          showNodeInfo(selectedNode);
          goToSpeaker(selectedNode.Label);
          highlightSpeaker(selectedNode.Label);
        }

        // Add proper nav info based on screen size (for mobile). We only update the font size here since this label is already written by the library at load time.
        function populateNavInfo() {
          if (window.innerWidth > 500) {
            document.getElementsByClassName(
              "scene-nav-info",
            )[0].style.fontSize = "15px";
            document.getElementsByClassName("scene-nav-info")[0].innerHTML =
              "Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan.";
          } else {
            document.getElementsByClassName(
              "scene-nav-info",
            )[0].style.fontSize = "12px";
            document.getElementsByClassName("scene-nav-info")[0].innerHTML =
              "Drag to rotate, Pinch to zoom, Two-finger drag to pan.";
          }

          if (backgroundColor === "dark") {
            document.getElementsByClassName("scene-nav-info")[0].style.color =
              "#fafafa";
          } else {
            document.getElementsByClassName("scene-nav-info")[0].style.color =
              "#222222";
          }
        }

        // Turn connections on or off. If there are a lot of lines it gets pretty costly to render in browser.
        function toggleConnections() {
          var button = document.getElementById("connectionsButton");

          if (connectionDisplay === 1) {
            connectionDisplay = 0;
            button.innerHTML = "Connections On";
          } else {
            connectionDisplay = 1;
            button.innerHTML = "Connections Off";
          }

          updateVisibleLinks();
        }

        // Display correct set of checkboxes
        function populateCheckboxes() {
          checkboxHolder = document.getElementById("checkbox-holder-global");

          if (coloring == 1) {
            checkboxHolder.innerHTML = checkboxes1;
          } else if (coloring == 2) {
            checkboxHolder.innerHTML = checkboxes2;
          } else {
            checkboxHolder.innerHTML = checkboxes;
          }
        }
        // Write content to Explanation sidebar tab (responsive based on number of dimensions currently displayed)
        function populateExplanation() {
          explanation = document.getElementById("explanation");
          explanation.innerHTML = `
                <h3>What am I looking at?</h3>
                <br>
                This diagram shows a social network of the Book of Mormon, i.e., who speaks to whom. Each sphere represents a speaker in the Book of Mormon.
                <br>
                <br>
                The speakers are connected by lines representing interactions. Larger spheres represent people with a higher number of recorded interactions.
                <br>
                <br>
                The speakers float in 3-D space.
                The connections ‘pull’ the nodes into their positions. The result is a ${dimensions}-D network grouped by similarity.
                <br>
                <br>
                Find more information in the <div class="appear" onclick="faqAppear()">FAQ</a>.            
                `;
        }

        // Decide. based on screen size, whether to show full or mobile-specific navigation instructions in the Instructions sidebar tab.
        function populateInstructions() {
          instructions = document.getElementById("instructions");

          if (window.innerWidth > 500) {
            instructions.innerHTML = `
                    <h3>Navigation</h3>
                    <br>Click and drag to rotate the network, or use the mouse wheel to zoom. 
                    <br><br>Click a node to highlight its connections, or click the background without dragging to return the graph to normal.
                    <br>Right-click any node to see its information in the node-information tab below.
                    <br><br>Use the buttons in the bottom-right corner to specify a node, then click "Go!" and the selected node will appear in the center of the screen.
                    <br>
                    <br>Check or uncheck legend items in the legend tab to toggle their display.
                    `;
          } else {
            instructions.innerHTML = `
                    <h3>Navigation</h3>
                    <br>Drag to rotate the network, or pinch to zoom. Drag with two fingers to pan.
                    <br>Tap any node to highlight its connections, or tap the background without dragging to return the graph to normal.
                    <br><br>Use the buttons in the bottom-right corner to specify a node, then click "Go!" and the selected node will appear in the center of the screen.
                    <br>
                    <br>Check or uncheck legend items in the legend tab to toggle their display.
                    `;
          }
        }

        // Display info about a given node (usually when clicked)
        function showNodeInfo(node) {
          var info = document.getElementById("info");
          var url = "../../Images/" + node.Label + ".jpg";

          // get the nodes structure
          var nodes_struct = Graph.graphData().nodes;
          var links = Graph.graphData().links;

          // get the IDs
          var IDs = node.Ids.split(" ");
          let size = IDs.length;

          /*    // Niki trying to make the checkboxes match the selected node
          // It's not working.

            colorNodes.clear();
          
            // make a list of connections
            var list = [];
            var listcnt = 0;

            var legend_checkboxes = "<div id=\"checkbox-holder\">";

             // include the selected speaker
                legend_checkboxes += "<label class=\"container\">"
                + node.Label 
                + "<input type=\"checkbox\" id=\"" + 
                + node.Name 
                + "\" onclick=\"check(speakers2)\"><span class=\"checkmark " 
                + node.Name 
                + "\"></span> </label> ";

                // add the selected node to the list
                list[listcnt] = node.Name;
                listcnt++;
                colorNodes.add(node.ID);
           
            // make the other checkboxes
            for(let i = 0; i < size; i++)
            {
                colorNodes.add(IDs[i]);
                legend_checkboxes += "<label class=\"container\">"
                + nodes_struct[IDs[i]].Label 
                + "<input type=\"checkbox\" id=\"" + 
                + nodes_struct[IDs[i]].Name 
                + "\" onclick=\"check(" + nodes_struct[IDs[i]].Name 
                + ")\"><span class=\"checkmark " 
                + nodes_struct[IDs[i]].Name 
                + "\"></span> </label> ";

                list[listcnt] = nodes_struct[IDs[i]].Name;
                listcnt++;
            }
            legend_checkboxes += "</div>";

            for (var i = 0; i < listcnt; i++) {
              document.getElementById(list[i]).checked = true;
            }
            // iterate over links, add correct ones to the set
            for (index = 0; index < links.length; index++) {
                link = links[index];                
                
                if (colorNodes.has(link.source)) {
                        if (colorNodes.has(link.target)) {
                            highlightLinks.add(link);   
                        }
                }
            }
// End Niki trying to get the checkboxes to work
                             */

          info.innerHTML = `<div id ='nodeinfo'>
                <h3>Speaker:</h3>
                ${node.Label}<br>
                <br>
                    <img src="${url}" alt="Portrait of ${node.Label}"><br>
                <br>
                <h3>Basic Info:</h3>
                ${node.Blurb}<br>
                <br>        
                <h3>Spoke With:</h3>
                ${node.Docs}<br>
                </div>
            `;
          updateVisibleLinks();
          Graph.nodeVisibility((node) => (colorNodes.has(node) ? 1 : 0));
        }

        // Display info about a given link (usually when clicked)
        function showLinkInfo(link) {
          var info = document.getElementById("info");
          var href = `<a href="${link.Link}" target="blank">${link.Verse}</a>`;
          info.innerHTML = `<div id ='nodeinfo'>
                <h3>Speakers:</h3>
                ${link.Speaker1}<br>
                ${link.Speaker2}<br>
                <br>
                <h3>Scripture:</h3>
                ${href}<br>
                ${link.Idea}<br>
                <br>        
                </div>
            `;
        }

        // Move to a speaker (rather than just a node)
        function goToSpeaker(speaker) {
          destroyLabel();
          if (speakers.includes(speaker)) {
            document.getElementById("bookSelect").value = speaker;
            highlightSpeaker(speaker);
            setTimeout(() => {
              createLabel(speaker);
            }, 1000);
          }
        }

        // Make and position a label for a given speaker
        function createLabel(speaker) {
          // Get rid of old label
          destroyLabel();
          // Ensure we have a node to anchor to
          if (!selectedNode || selectedNode.Label !== speaker) {
            const nodes = Graph.graphData().nodes || [];
            for (let i = 0; i < nodes.length; i++) {
              if (nodes[i] && nodes[i].Label === speaker) {
                selectedNode = nodes[i];
                break;
              }
            }
          }
          if (!selectedNode) return;

          // Create a new div element
          const newDiv = document.createElement("div");
          // Put someting in the div
          newDiv.innerHTML = `${speaker}`;
          // Give class to popup
          newDiv.id = "popup";

          if (backgroundColor == "dark") {
            newDiv.style.backgroundColor = transparentDark;
            newDiv.style.color = "#eee";
          } else {
            newDiv.style.backgroundColor = transparentlight;
            newDiv.style.color = "#222222";
          }

          document.body.append(newDiv);
          // Keep the popup pinned to the node even while rotating/zooming/panning.
          startPopupTracking();
        }

        // Destroy popup label if one exists
        function destroyLabel() {
          stopPopupTracking();
          var label = document.getElementById("popup");
          if (label == null) {
          } else {
            label.remove();
          }
        }

        // Function to position any element anywhere on screen
        function positionElement(element, x, y) {
          element.style.left = x + "px";
          element.style.top = y + "px";
        }

        // --- Popup label tracking (keep the label next to the selected node) ---
        let popupRafId = null;

        function stopPopupTracking() {
          if (popupRafId !== null) {
            cancelAnimationFrame(popupRafId);
            popupRafId = null;
          }
        }

        function startPopupTracking() {
          stopPopupTracking();

          const tick = () => {
            const label = document.getElementById("popup");
            if (!label || !selectedNode) {
              popupRafId = null;
              return;
            }

            // Keep the label text in sync with the currently selected node.
            // (We reuse the same DOM element across selections.)
            const desiredText = selectedNode.Label || selectedNode.Name || "";
            if (label.textContent !== desiredText) label.textContent = desiredText;

            const canvas = document.querySelector("#graph-3d canvas");
            if (!canvas) {
              popupRafId = requestAnimationFrame(tick);
              return;
            }

            const canvasRect = canvas.getBoundingClientRect();
            const coords = Graph.graph2ScreenCoords(
              selectedNode.x,
              selectedNode.y,
              selectedNode.z,
            );

            // graph2ScreenCoords() is canvas-relative; convert to viewport coords.
            // Small offset so the label doesn't cover the node.
            positionElement(
              label,
              canvasRect.left + coords.x + 12,
              canvasRect.top + coords.y - 12,
            );

            popupRafId = requestAnimationFrame(tick);
          };

          popupRafId = requestAnimationFrame(tick);
        }

        // Highlight a given speaker's node and edges
        function highlightSpeaker(speaker) {
          var nodes = Graph.graphData().nodes;
          var node;

          for (index = 0; index < nodes.length; index++) {
            node = nodes[index];
            if (node["Label"] == speaker) {
              break;
            }
          }

          // Set the selected node for highlighting
          selectedNode = node;
          // Keep the main speaker dropdown in sync with the currently selected node.
          // This does not dispatch a change event (so it won't trigger flyToNode loops).
          if (selectedNode && selectedNode.Name) {
            const selectEl = document.getElementById("bookSelect");
            if (selectEl) selectEl.value = selectedNode.Name;
          }

          highlightMode = true;
          targetNodes.clear();
          targetNodes.add(node);

          // Clear the highlights of links and nodes
          inHighlightLinks.clear();
          outHighlightLinks.clear();
          incomingNodes.clear();
          outgoingNodes.clear();

          // Loop over all nodes and get ins and outs
          targetNodes.forEach((node) => {
            Nodes = node.Ids.split(" ");
            var outNum = Nodes.map(Number);
            var links = Graph.graphData().links;
            var nodes = Graph.graphData().nodes;
            outNum.forEach((num) => outgoingNodes.add(nodes[num]));
          });

          // Set which links to highlight
          var links = Graph.graphData().links;
          for (index = 0; index < links.length; index++) {
            link = links[index];
            if (targetNodes.has(link.source)) {
              inHighlightLinks.add(link);
            } else if (targetNodes.has(link.target)) {
              outHighlightLinks.add(link);
            }
          }

          check();
          setHighlightColor();
          updateVisibleLinks();
          legendSelectionEnter();
          showNodeInfo(node);
          closeAccordion();
          openTab("infoTab");
        }

        // Highlight a given node and its edges
        function highlightNode(label) {
          var node = label;

          // Set the selected node for highlighting
          selectedNode = node;
          // Keep the main speaker dropdown in sync with the currently selected node.
          if (selectedNode && selectedNode.Name) {
            const selectEl = document.getElementById("bookSelect");
            if (selectEl) selectEl.value = selectedNode.Name;
          }

          highlightMode = true;
          targetNodes.clear();
          targetNodes.add(node);

          // Clear the highlights of links and nodes
          inHighlightLinks.clear();
          outHighlightLinks.clear();
          incomingNodes.clear();
          outgoingNodes.clear();

          // Loop over all nodes and get ins and outs
          targetNodes.forEach((node) => {
            Nodes = node.Ids.split(" ");
            var outNum = Nodes.map(Number);
            var links = Graph.graphData().links;
            var nodes = Graph.graphData().nodes;
            outNum.forEach((num) => outgoingNodes.add(nodes[num]));
          });

          // Set which links to highlight
          var links = Graph.graphData().links;
          for (index = 0; index < links.length; index++) {
            link = links[index];
            if (targetNodes.has(link.source)) {
              inHighlightLinks.add(link);
            } else if (targetNodes.has(link.target)) {
              outHighlightLinks.add(link);
            }
          }

          check();
          setHighlightColor();
          updateVisibleLinks();

          // Switch legend into exact-people mode for the selected neighborhood
          legendSelectionEnter();

          // Navigate sidebar to highlighted speaker's info
          showNodeInfo(node);
          closeAccordion();
          openTab("infoTab");
        }

        // get Query variable from URL string
        function getQueryVariable(variable) {
          const urlParams = new URLSearchParams(window.location.search);
          if (urlParams.get("speaker") !== null) {
            speaker = urlParams.get("speaker");
            return speaker;
          } else {
            let path = window.location.pathname;
            let pathArray = path.substr(1).split("/");
            if (pathArray[1] == "speaker" && idNames.includes(pathArray[2])) {
              return pathArray[2];
            } // the variable isn't set
            else return null;
          }
        }

        // Fly to speaker from URL string
        function goToURLSpeaker() {
          speaker = getQueryVariable("speaker");
          if (speaker) {
            speaker = speaker.charAt(0).toUpperCase() + speaker.slice(1);
          } // force first letter uppercase
          if (speakers.includes(speaker)) {
            document.getElementById("bookSelect").value = speaker;
            goToSpeaker(speaker);
          } else return null;
        }

        // Functions for FAQ page popup; and to gray out the rest of the widget behind the FAQ popup.
        function faqDisappear() {
          elem = document.getElementById("faq");
          elem.style.visibility = "hidden";
          elem2 = document.getElementById("grey-out");
          elem2.style.visibility = "hidden";
        }

        function faqAppear() {
          elem = document.getElementById("faq");
          elem.style.visibility = "visible";
          elem2 = document.getElementById("grey-out");
          elem2.style.visibility = "visible";
        }

        // We set a little timeout to let the page load before doing all of this stuff. It ensures a smooth load.
        setTimeout(() => {
          goToURLSpeaker();
        }, 2500);
        setTimeout(() => {
          check();
        }, 250);
        setTimeout(() => {
          resetGraph();
        }, 500);

        // Now, execute the functions necessary to start the first initial page
        populateExplanation();
        populateCheckboxes();
        populateInstructions();
        populateNavInfo();
        // We only want to open the explanation tab if we're not on mobile
        if (window.innerWidth > 500) {
          openTab("explanationTab");
        }
        resizeGraph();
        checkAll(true);
        Graph.nodeVisibility(1);
        setSidebarSize(sideSizeMin, sideSizeMax);
        changeBackgroundColor();
      </script>
    </div>
  </body>
</html>
